write simple adsr in c++
ChatGPT
Here's an example implementation of a simple Attack-Decay-Sustain-Release (ADSR) envelope generator in C++:

cpp
Copy code
class ADSR {
public:
    ADSR(float attackTime, float decayTime, float sustainLevel, float releaseTime, float sampleRate) :
        attackTime_(attackTime),
        decayTime_(decayTime),
        sustainLevel_(sustainLevel),
        releaseTime_(releaseTime),
        sampleRate_(sampleRate),
        state_(State::Idle),
        envelope_(0.0f),
        phase_(0),
        sampleCount_(0)
    {
        calculateCoefficients();
    }

    void setAttackTime(float attackTime) {
        attackTime_ = attackTime;
        calculateCoefficients();
    }

    void setDecayTime(float decayTime) {
        decayTime_ = decayTime;
        calculateCoefficients();
    }

    void setSustainLevel(float sustainLevel) {
        sustainLevel_ = sustainLevel;
    }

    void setReleaseTime(float releaseTime) {
        releaseTime_ = releaseTime;
        calculateCoefficients();
    }

    void setSampleRate(float sampleRate) {
        sampleRate_ = sampleRate;
        calculateCoefficients();
    }

    void noteOn() {
        if (state_ == State::Idle) {
            state_ = State::Attack;
            sampleCount_ = 0;
            phase_ = 0;
        }
    }

    void noteOff() {
        if (state_ != State::Idle) {
            state_ = State::Release;
            sampleCount_ = 0;
            phase_ = 0;
        }
    }

    float process() {
        float output = 0.0f;

        switch (state_) {
            case State::Attack:
                envelope_ += attackCoefficient_;
                if (envelope_ >= 1.0f) {
                    envelope_ = 1.0f;
                    state_ = State::Decay;
                }
                break;
            case State::Decay:
                envelope_ -= decayCoefficient_;
                if (envelope_ <= sustainLevel_) {
                    envelope_ = sustainLevel_;
                    state_ = State::Sustain;
                }
                break;
            case State::Sustain:
                envelope_ = sustainLevel_;
                break;
            case State::Release:
                envelope_ -= releaseCoefficient_;
                if (envelope_ <= 0.0f) {
                    envelope_ = 0.0f;
                    state_ = State::Idle;
                }
                break;
            case State::Idle:
                envelope_ = 0.0f;
                break;
        }

        output = envelope_;

        ++sampleCount_;

        return output;
    }

private:
    enum class State {
        Idle,
        Attack,
        Decay,
        Sustain,
        Release
    };

    float attackTime_;
    float decayTime_;
    float sustainLevel_;
    float releaseTime_;
    float sampleRate_;
    State state_;
    float envelope_;
    float attackCoefficient_;
    float decayCoefficient_;
    float releaseCoefficient_;
    size_t phase_;
    size_t sampleCount_;

    void calculateCoefficients() {
        attackCoefficient_ = 1.0f / (attackTime_ * sampleRate_);
        decayCoefficient_ = (1.0f - sustainLevel_) / (decayTime_ * sampleRate_);
        releaseCoefficient_ = envelope_ / (releaseTime_ * sampleRate_);
    }
};
The ADSR class represents an Attack-Decay-Sustain-Release envelope generator. It takes parameters such as attack time, decay time, sustain level, release time, and sample rate in the constructor.

The envelope generator has different states (Idle, Attack, Decay, Sustain, Release) to control the progression of the envelope based on the current phase. The noteOn function triggers the attack phase, while the noteOff function triggers the release phase.

The process function advances the envelope generator by one sample. It updates the envelope value based on the current state and coefficients. The output value is the current envelope value.

You can create an instance of the ADSR class, set the desired parameters, and call the process function repeatedly to generate the envelope values over time. The envelope values can then be used to control various aspects of sound generation or processing, such as volume, filter cutoff, or modulation intensity.